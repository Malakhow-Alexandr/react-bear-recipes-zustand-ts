{"version":3,"file":"static/js/544.d6ed8380.chunk.js","mappings":"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","sources":["../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/zustand/esm/vanilla.mjs","../node_modules/zustand/esm/index.mjs","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/zustand/esm/middleware.mjs","../node_modules/immer/src/utils/env.ts","../node_modules/immer/src/utils/errors.ts","../node_modules/immer/src/utils/common.ts","../node_modules/immer/src/utils/plugins.ts","../node_modules/immer/src/core/scope.ts","../node_modules/immer/src/core/finalize.ts","../node_modules/immer/src/core/proxy.ts","../node_modules/immer/src/core/immerClass.ts","../node_modules/immer/src/core/current.ts","../node_modules/immer/src/immer.ts","../node_modules/zustand/esm/middleware/immer.mjs"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport { useDebugValue } from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tObject.entries(obj).forEach(([key, value]) => {\n\t\t\titer(key, value, obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: boolean) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tif (!strict && isPlainObject(base)) {\n\t\tif (!getPrototypeOf(base)) {\n\t\t\tconst obj = Object.create(null)\n\t\t\treturn Object.assign(obj, base)\n\t\t}\n\t\treturn {...base}\n\t}\n\n\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = Reflect.ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: boolean = false\n\n\tconstructor(config?: {autoFreeze?: boolean; useStrictShallowCopy?: boolean}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: boolean) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n","import { produce } from 'immer';\n\nconst immerImpl = (initializer) => (set, get, store) => {\n  store.setState = (updater, replace, ...a) => {\n    const nextState = typeof updater === \"function\" ? produce(updater) : updater;\n    return set(nextState, replace, ...a);\n  };\n  return initializer(store.setState, get, store);\n};\nconst immer = immerImpl;\n\nexport { immer };\n"],"names":["e","require","k","Object","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","value","d","f","u","window","document","createElement","inst","c","g","exports","useSyncExternalStore","h","q","t","useRef","v","useMemo","w","useSyncExternalStoreWithSelector","current","hasValue","module","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","createStoreImpl","createState","state","listeners","Set","setState","partial","replace","nextState","previousState","assign","listener","getState","api","subscribe","add","delete","destroy","console","warn","clear","createStore","useSyncExternalStoreExports","createImpl","useBoundStore","selector","equalityFn","undefined","slice","getServerState","useStore","create","_objectWithoutProperties","excluded","sourceKeys","indexOf","sourceSymbolKeys","prototype","propertyIsEnumerable","call","trackedConnections","Map","getTrackedConnectionState","name","get","fromEntries","entries","stores","map","_ref","_ref2","_slicedToArray","devtools","fn","devtoolsOptions","set","extensionConnector","enabled","anonymousActionType","store","options","_excluded","__REDUX_DEVTOOLS_EXTENSION__","_extractConnectionInf","type","connection","connect","existingConnection","_objectSpread","newConnection","extractConnectionInformation","connectionInformation","_excluded2","isRecording","nameOrAction","action","send","concat","setStateFromDevtools","originalIsRecording","initialState","init","_ref3","_ref4","store2","dispatchFromDevtools","dispatch","didWarnAboutReservedActionType","originalDispatch","_len","Array","_key","message","_a","payload","error","parseJsonThen","stateFromDevtools","JSON","stringify","nextLiftedState","lastComputedState","computedStates","stringified","parsed","parse","NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","die","Error","getPrototypeOf","isDraft","isDraftable","_value$constructor","isPlainObject","isArray","constructor","isMap","isSet","objectCtorString","toString","proto","Ctor","hasOwnProperty","Function","each","iter","getArchtype","entry","index","thing","type_","has","prop","propOrOldValue","latest","copy_","base_","shallowCopy","base","strict","descriptors","Reflect","desc","freeze","deep","isFrozen","dontMutateFrozenCollections","currentScope","plugins","getPlugin","pluginKey","plugin","getCurrentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer2","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","isSet2","generatePatches_","parentState","targetObject","rootPath","targetIsSet","res","assigned_","autoFreeze_","objectTraps","_desc$get","getDescriptorFromProto","draft_","readPropFromProto","peek","prepareCopy","createProxy","x","y","current2","currentState","markChanged","Number","isNaN","deleteProperty","owner","setPrototypeOf","arrayTraps","useStrictShallowCopy_","this","Immer2","config","_this","_classCallCheck","produce","recipe","defaultBase","self","_this2","base2","_len2","args","_key3","_recipe","proxy","hasError","ip","produceWithPatches","_len3","_key4","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","_createClass","currentImpl","isManual_","patch","op","applyPatchesImpl","applyPatches_","parent","proxyMap_","proxySet_","traps","_Proxy$revocable","Proxy","revocable","revoke","createProxyProxy","copy","immer","bind","applyPatches","createDraft","finishDraft","initializer","updater"],"sourceRoot":""}
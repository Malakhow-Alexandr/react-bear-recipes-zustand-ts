{"version":3,"file":"static/js/544.a96ef0b9.chunk.js","mappings":"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","sources":["../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/zustand/esm/vanilla.mjs","../node_modules/zustand/esm/index.mjs","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/zustand/esm/middleware.mjs","../node_modules/immer/src/utils/env.ts","../node_modules/immer/src/utils/errors.ts","../node_modules/immer/src/utils/common.ts","../node_modules/immer/src/utils/plugins.ts","../node_modules/immer/src/core/scope.ts","../node_modules/immer/src/core/finalize.ts","../node_modules/immer/src/core/proxy.ts","../node_modules/immer/src/core/immerClass.ts","../node_modules/immer/src/core/current.ts","../node_modules/immer/src/immer.ts","../node_modules/zustand/esm/middleware/immer.mjs"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport { useDebugValue } from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tObject.entries(obj).forEach(([key, value]) => {\n\t\t\titer(key, value, obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: boolean) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tif (!strict && isPlainObject(base)) {\n\t\tif (!getPrototypeOf(base)) {\n\t\t\tconst obj = Object.create(null)\n\t\t\treturn Object.assign(obj, base)\n\t\t}\n\t\treturn {...base}\n\t}\n\n\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = Reflect.ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: boolean = false\n\n\tconstructor(config?: {autoFreeze?: boolean; useStrictShallowCopy?: boolean}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: boolean) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n","import { produce } from 'immer';\n\nconst immerImpl = (initializer) => (set, get, store) => {\n  store.setState = (updater, replace, ...a) => {\n    const nextState = typeof updater === \"function\" ? produce(updater) : updater;\n    return set(nextState, replace, ...a);\n  };\n  return initializer(store.setState, get, store);\n};\nconst immer = immerImpl;\n\nexport { immer };\n"],"names":["e","require","k","Object","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","value","d","f","u","window","document","createElement","inst","c","g","exports","useSyncExternalStore","h","q","t","useRef","v","useMemo","w","useSyncExternalStoreWithSelector","current","hasValue","module","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","createStoreImpl","createState","state","listeners","Set","setState","partial","replace","nextState","previousState","assign","listener","getState","api","subscribe","add","delete","destroy","console","warn","clear","createStore","useSyncExternalStoreExports","createImpl","useBoundStore","selector","equalityFn","undefined","slice","getServerState","useStore","create","_objectWithoutProperties","excluded","sourceKeys","indexOf","sourceSymbolKeys","prototype","propertyIsEnumerable","call","trackedConnections","Map","getTrackedConnectionState","name","get","fromEntries","entries","stores","map","_ref","_ref2","_slicedToArray","devtools","fn","devtoolsOptions","set","extensionConnector","enabled","anonymousActionType","store","options","_excluded","__REDUX_DEVTOOLS_EXTENSION__","_extractConnectionInf","type","connection","connect","existingConnection","_objectSpread","newConnection","extractConnectionInformation","connectionInformation","_excluded2","isRecording","nameOrAction","action","send","concat","setStateFromDevtools","originalIsRecording","initialState","init","_ref3","_ref4","store2","dispatchFromDevtools","dispatch","didWarnAboutReservedActionType","originalDispatch","_len","Array","_key","message","_a","payload","error","parseJsonThen","stateFromDevtools","JSON","stringify","nextLiftedState","lastComputedState","computedStates","stringified","parsed","parse","createJSONStorage","getStorage","storage","getItem","str2","reviver","str","Promise","then","setItem","newValue","replacer","removeItem","toThenable","input","result","onFulfilled","catch","_onRejected","this","_onFulfilled","onRejected","persist","config","baseOptions","localStorage","serialize","deserialize","partialize","version","merge","persistedState","currentState","hasHydrated","hydrationListeners","finishHydrationListeners","thenableSerialize","errorInSync","thenable","serializedValue","savedSetState","stateFromStorage","configResult","hydrate","cb","postRehydrationCallback","onRehydrateStorage","bind","storageValue","deserializedStorageValue","migrate","migratedState","_a2","setOptions","newOptions","clearStorage","getOptions","rehydrate","onHydrate","onFinishHydration","oldImpl","_b","skipHydration","newImpl","NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","die","Error","getPrototypeOf","isDraft","isDraftable","_value$constructor","isPlainObject","isArray","constructor","isMap","isSet","objectCtorString","toString","proto","Ctor","hasOwnProperty","Function","each","iter","getArchtype","entry","index","thing","type_","has","prop","propOrOldValue","latest","copy_","base_","shallowCopy","base","strict","descriptors","Reflect","desc","freeze","deep","isFrozen","dontMutateFrozenCollections","currentScope","plugins","getPlugin","pluginKey","plugin","getCurrentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer2","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","isSet2","generatePatches_","parentState","targetObject","rootPath","targetIsSet","res","assigned_","autoFreeze_","objectTraps","_desc$get","getDescriptorFromProto","draft_","readPropFromProto","peek","prepareCopy","createProxy","x","y","current2","markChanged","Number","isNaN","deleteProperty","owner","setPrototypeOf","arrayTraps","useStrictShallowCopy_","Immer2","_this","_classCallCheck","produce","recipe","defaultBase","self","_this2","base2","_len2","args","_key3","_recipe","proxy","hasError","ip","produceWithPatches","_len3","_key4","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","_createClass","currentImpl","isManual_","patch","op","applyPatchesImpl","applyPatches_","parent","proxyMap_","proxySet_","traps","_Proxy$revocable","Proxy","revocable","revoke","createProxyProxy","copy","immer","applyPatches","createDraft","finishDraft","initializer","updater"],"sourceRoot":""}